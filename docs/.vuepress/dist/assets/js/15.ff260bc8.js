(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{586:function(e,t,r){"use strict";r.r(t);var a=r(31),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"盒子模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型"}},[e._v("#")]),e._v(" 盒子模型")]),e._v(" "),r("h4",{attrs:{id:"盒模型有两种"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#盒模型有两种"}},[e._v("#")]),e._v(" 盒模型有两种：")]),e._v(" "),r("p",[e._v("IE 盒子模型(怪异盒模型)、W3C 盒子模型")]),e._v(" "),r("h4",{attrs:{id:"区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[e._v("#")]),e._v(" 区别：")]),e._v(" "),r("p",[e._v("IE盒子模型的 width和height包含了content、border 和 padding三个部分；"),r("br"),e._v("\nW3C标准盒子模型的width和height就是指content的。")]),e._v(" "),r("h4",{attrs:{id:"盒模型可以通过css的属性box-sizing设置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#盒模型可以通过css的属性box-sizing设置"}},[e._v("#")]),e._v(" 盒模型可以通过css的属性box-sizing设置：")]),e._v(" "),r("p",[e._v("content-box——默认值，也就是W3C盒模型；"),r("br"),e._v("\nborder-box——IE盒模型")]),e._v(" "),r("h4",{attrs:{id:"由内到外的组成顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#由内到外的组成顺序"}},[e._v("#")]),e._v(" 由内到外的组成顺序：")]),e._v(" "),r("p",[e._v("content内容、padding内边距/内填充、border边框、margin外边距，其中padding、border和margin都包括上下左右（top、bottom、left、right）四个方向。")]),e._v(" "),r("h2",{attrs:{id:"弹性盒模型flex"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#弹性盒模型flex"}},[e._v("#")]),e._v(" 弹性盒模型flex")]),e._v(" "),r("ul",[r("li",[e._v("弹性盒的兼容性不是很好，但是很适合在移动端使用")]),e._v(" "),r("li",[e._v("弹性盒的使用可以省去我们很大的代码量看起来更加简洁")]),e._v(" "),r("li",[e._v("当然如果不考虑低版本的 IE，你可以放心大胆的用")])]),e._v(" "),r("h4",{attrs:{id:"针对父容器的属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#针对父容器的属性"}},[e._v("#")]),e._v(" 针对父容器的属性：")]),e._v(" "),r("p",[r("code",[e._v("flex-direction：row(默认值)/row-reverse/colum/colum-reverse；")]),e._v("——主轴排列方向"),r("br"),e._v(" "),r("code",[e._v("display：flex；")]),e._v("——使盒子变为弹性盒模型，默认为主轴方向为水平排列"),r("br"),e._v(" "),r("code",[e._v("justify-content：flex-start(默认值)/center/flex-end/space-between/space-around；")]),e._v("——主轴排列方式"),r("br"),e._v(" "),r("code",[e._v("align-items：strech(默认值)/flex-start/center/flex-end/baseline；")]),e._v("——侧轴对齐方式"),r("br"),e._v(" "),r("code",[e._v("flex-wrap：nowrap(默认值)/wrap/wrap-reverse；")]),e._v("——是否换行"),r("br"),e._v(" "),r("code",[e._v("align-content：strech(默认值)/flex-start/flex-end/center/space-between/spce-around；")]),e._v("——行之间的对齐方式"),r("br")]),e._v(" "),r("h4",{attrs:{id:"针对子元素的属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#针对子元素的属性"}},[e._v("#")]),e._v(" 针对子元素的属性：")]),e._v(" "),r("p",[r("code",[e._v("order：0/1/2/...；")]),e._v("——排序，值越大，排的越靠后"),r("br"),e._v(" "),r("code",[e._v("align-self：auto/strech/flex-start/center/flex-end；")]),e._v("——自身对齐方式(以所在一行的高度为标准)"),r("br"),e._v(" "),r("code",[e._v("flex：1/2/3；")]),e._v("——按比例自适应容器"),r("br"),e._v(" "),r("code",[e._v("flex-grow：0/1；")]),e._v("——定义项目的放大比例，默认为0"),r("br"),e._v(" "),r("code",[e._v("flex-shrink：0/1；")]),e._v("——定义项目的缩小比例，默认为1"),r("br"),e._v("\n注：弹性和模型中如果子元素不设置宽度，宽度由内容决定。")]),e._v(" "),r("h2",{attrs:{id:"flex属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flex属性"}},[e._v("#")]),e._v(" flex属性！")]),e._v(" "),r("h4",{attrs:{id:"flex-1-flex-1-1-任意数字-任意长度单位"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flex-1-flex-1-1-任意数字-任意长度单位"}},[e._v("#")]),e._v(" flex:1; === flex: 1 1 任意数字+任意长度单位;")]),e._v(" "),r("ul",[r("li",[e._v("第一个参数表示: flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大")]),e._v(" "),r("li",[e._v("第二个参数表示: flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小")]),e._v(" "),r("li",[e._v("第三个参数表示: flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小")])]),e._v(" "),r("br"),e._v("\n可以看出最重要的一点在 第三个参数 flex-basis 上, 我们再来回顾以下 这个属性的作用\nflex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小\nauto 为表示项目本身的大小, 如果设置为 auto, 那么这三个盒子就会按照自己内容的多少来等比例的放大和缩小, 所以出现了上图中三个盒子不一样大的情况\n那我们如果随便设置一个其他带有长度单位的数字呢, 那么他就不会按项目本身来计算, 所以它不关心内容, 只是把空间等比收缩和放大\n"),r("vssue",{attrs:{options:{locale:"zh"}}})],1)}),[],!1,null,null,null);t.default=s.exports}}]);